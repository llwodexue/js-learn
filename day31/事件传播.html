<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>事件传播</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #outer {
            overflow: hidden;
            width: 200px;
            height: 200px;
            background: yellow;
            margin: 100px auto;
        }

        #inner {
            overflow: hidden;
            width: 100px;
            height: 100px;
            background: yellowgreen;
            margin: 50px auto;
        }

        #center {
            width: 50px;
            height: 50px;
            background: green;
            margin: 25px auto;
        }
    </style>
</head>

<body>
    <div id="outer">
        <div id="inner">
            <div id="center"></div>
        </div>
    </div>
</body>

</html>
<script>
    let outer = document.getElementById("outer")
    let inner = document.getElementById("inner")
    let center = document.getElementById("center")
    // outer.onclick = (e) => {
    //     console.log("outer", e.target);
    // }
    // inner.onclick = (e) => {
    //     console.log("inner", e.target);
    // }
    // center.onclick = (e) => {
    //     console.log("center", e.target);
    // }
    // 事件传播机制：由于DOM0级事件绑定默认存在事件冒泡机制，所以当点击的元素的事件触发时，会从里往外依次触发父级元素身上的对应事件

    // document.body.onclick = ()=>{
    //     console.log("body");
    // }
    // document.documentElement.onclick = ()=>{
    //     console.log("html");
    // }
    // window.onclick = ()=>{
    //     console.log("window");
    // }

    // let f1 = () => { console.log("outer捕获"); }
    // let f2 = () => { console.log("inner捕获"); }
    // let f3 = () => { console.log("center捕获"); }
    // let f4 = () => { console.log("outer冒泡"); }
    // let f5 = () => { console.log("inner冒泡"); }
    // let f6 = () => { console.log("center冒泡"); }
    // outer.addEventListener("click", f4, false)
    // outer.addEventListener("click", f1, true)
    // inner.addEventListener("click", f5, false)
    // inner.addEventListener("click", f2, true)
    // center.addEventListener("click", f6, false)
    // center.addEventListener("click", f3, true)
    // 如果第三个参数是false那就是给冒泡阶段绑定方法
    // 如果第三个参数是true那就是给捕获阶段绑定方法
    // 在目标阶段，执行方法时，先绑定的谁就执行谁，跟绑定的时候第三个参数没有关系
    // 方法执行的时候分三个阶段，分别是捕获阶段（从外往里找）、目标阶段（按绑定的先后顺序执行）、冒泡阶段（从里往外执行）

    // 当事件触发的事先执行捕获阶段
    // 捕获阶段
    // 目标阶段
    // 冒泡阶段

    // onmouseover/onmouseout（有冒泡机制）
    // onmouseenter/onmouseleave（没有冒泡机制）

    outer.onmouseover = () => { console.log("outer");}
    inner.onmouseover = () => { console.log("inner");}
    center.onmouseover = () => { console.log("center");}
</script>