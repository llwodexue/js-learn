# 基础题

## 1.原型链继承

![](https://gitee.com/lilyn/pic/raw/master/js-img/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%83%E4%B9%A01.jpg)

```js
function Fn(){
  let a = 1;
  this.a = a;
}
Fn.prototype.say = function(){
  this.a = 2;
}
Fn.prototype = new Fn;
let f1 = new Fn;
Fn.prototype.b = function(){
  this.a = 3;
};
console.log(f1.a); // 1
// 函数才有prototype，f1是实例对象会一层一层网上找prototype属性
console.log(f1.prototype); // undefined
console.log(f1.b); // 函数
console.log(f1.hasOwnProperty('b')); // false
console.log('b' in f1); // true
console.log(f1.constructor == Fn); // true
```

检测某个属性是否为当前对象的属性：

- in：不论是私有还是公有属性（原型链），只要有结果就是 true
- hasOwnProperty：检测是否为对象的私有属性，只要私有中没有这个属性，结果就是 false

检测当前属性是否为对象的公有属性

```js
function hasPubProperty(obj, attr) {
  // 局限性：如果私有中有这个属性，公有也有，此方法检测不准确
  return attr in obj && obj.hasOwnProperty(attr)
}
```

按照原型链查找，可以解决这个问题

```js
Object.prototype.hasPubProperty = function hasPubProperty(attr) {
  // this -> obj
  /* let self = this,
    prototype = Object.getPrototypeOf(self)
  while (prototype) {
    if (prototype.hasOwnProperty(attr)) {
      return true
    }
    prototype = Object.getPrototypeOf(self)
  }
  return false */

  // in操作符特点：先看自己私有中是否有，如果没有会默认按照原型链一层层查找
  let self = this,
    prototype = Object.getPrototypeOf(self)
  return attr in prototype
}
```

## 2.queryURLParams （至少两种方案）

问号参数的获取格式：urlencoded `xxx=xxx&xxx=xxx`

- 客户端页面跳转的时候，基于问号传递参数实现数据的传输
- 客户端向服务器发送请求，GET 系列请求都是基于问号参数实现数据传递的
- 前端路由中，组件和组件之间的通信也是基于问号传参

```js
let url = 'http://www.baidu.com/?lx=1&from=wx#video'
console.log(url.queryURLParams()) // { lx: '1', from: 'wx', HASH: 'video' }
console.log(url.queryURLParams('from'))  // 'wx'
console.log(url.queryURLParams('HASH')) // 'video'
```

1. 字符串截取处理
   - ？有 #有，？ 在前：`？+1~#` `#~#+1`
   - ？有 #有，# 在前：`？+1~''` `#+1~？`
   - ？有 #无：`？+1~''`
   - ？无 #有：'`'~#+1`

```js
String.prototype.queryURLParams = function queryURLParams(attr) {
  let self = this,
    obj = {}

  let askIndex = self.indexOf('?'),
    wellIndex = self.indexOf('#'),
    askText = '',
    wellText = ''
  askIndex === -1 ? (askIndex = self.length) : null
  wellIndex === -1 ? (wellIndex = self.length) : null
  if (askIndex < wellIndex) {
    askText = self.substring(askIndex + 1, wellIndex)
    wellText = self.substring(wellIndex + 1)
  } else {
    askText = self.substring(askIndex + 1)
    wellText = self.substring(wellIndex + 1, wellIndex)
  }
  // #获取信息
  if (wellText) obj['HASH'] = wellText
  if (askText) {
    askText = askText.split('&').forEach(item => {
      let [key, val] = item.split('=')
      obj[key] = val
    })
  }
  return typeof attr === 'undefined' ? obj : obj[attr]
}
```

2. 利用A元素对象的相关属性 [OOP]

```js
String.prototype.queryURLParams = function queryURLParams(attr) {
  let self = this,
    obj = {}

  let link = document.createElement('a')
  link.href = self
  let { search, hash } = link
  link = null
  if (hash) obj['HASH'] = hash.substring(1)
  if (search) {
    search = search.substring(1)
    search = search.split('&').forEach(item => {
      let [key, val] = item.split('=')
      obj[key] = val
    })
  }

  return typeof attr === 'undefined' ? obj : obj[attr]
}
```

3. 正则处理

```js
String.prototype.queryURLParams = function queryURLParams(attr) {
  let self = this,
    obj = {}
  
  let reg1 = /([^?&=#]+)=([^?&=#]+)/g,
    reg2 = /#([^?&=#]+)/g
  self.replace(reg1, (_, key, val) => (obj[key] = val))
  self.replace(reg2, (_, hash) => (obj['HASH'] = hash))
  return typeof attr === 'undefined' ? obj : obj[attr]
}
```

## 3.基于 ES6 中的 class 重构下面的代码

```js
function Modal(x,y){
  this.x = x;
  this.y = y;
}
Modal.prototype.z = 10;
Modal.prototype.getX = function(){
  console.log(this.x);
}
Modal.prototype.getY = function(){
  console.log(this.y);
}
Modal.n = 200;
Modal.setNumber = function(n){
  this.n = n;
};
let m = new Modal(10,20);
```

重构后如下：

```js
class Model {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
  getX() {
    console.log(this.x)
  }
  getY() {
    console.log(this.y)
  }
  static n = 200
  static setNumber(n) {
    this.n = n
  }
}
Modal.prototype.z = 10
```

## 4.类数组转数组

```js
let utils = (function(){
  function toArray(){
  //arguments 类数组集合
  //return [...arguments];
  //return Array.from(arguments);
  return [].slice.call(arguments);
  }
  
  return {
    toArray
  };
})();
let ary = utils.toArray(10,20,30) // [10,20,30]
ary = utils.toArray('A',10,20,30) // ['A',10,20,30]
```

## 5.对象（数组）的深克隆和浅克隆【37课时】

```js
// 浅克隆：只复制对象或者数组的第一级内容
// 深克隆：克隆后数组的每一级都和原始数组没有关联
let obj = {
  a: 100,
  b: [10, 20, 30],
  c: {
    x: 10,
  },
  d: /^\d+$/,
}
let arr = [
  10,
  [100, 200],
  {
    x: 10,
    y: 20,
  },
]
```

## 6.实现instanceof【33课时】

```js
// example:要检测的实例
// classFunc:要检测的类
function instance_of(example, classFunc) {
  //...
}
let res = instance_of([12, 23], Array)
console.log(res) //=>true
```

# 附加题

## 1.实现toType类型检测【34课时】

```js
function toType(obj) {
  //...
}
console.log(toType(1))       // "number"
console.log(toTYpe(NaN))     // "number"
console.log(toTYpe([]))      // "array"
console.log(toTYpe(/^\d+$/)) // "regexp"
console.log(toTYpe({}))      // "object"
```

## 2.实现call

```js
~(function () {
  /* 内置CALL实现原理 */
  function change() {
    //=>实现你的代码
  }
  Function.prototype.change = change
})()
let obj = { name: 'Alibaba' }
function func(x, y) {
  this.total = x + y
  return this
}
let res = func.change(obj, 100, 200) // {name:'Alibaba',total:300}
```

注意1：临时设置的属性，不能和原始对象冲突，所以属性采用唯一值处理

- 使用 `Symbol`
- 生成随机字符串 `Math.random() * new Date()`

注意2：如果 context 不是对象（是原始值），需要将其处理成对象。如果是 context 是 null 则需要单独处理

```js
~(function () {
  /* 内置CALL实现原理 */
  const createRandom = () => {
    let ran = Math.random() * new Date()
    return ran.toString(16).replace('.', '')
  }
  function change(context, ...params) {
    /*
    this -> 要执行的函数
    context -> 要改变函数中this的指向
    params -> 未来要传递给函数func的实参信息
    临时设置的属性，不能和原始对象冲突，所以属性采用唯一值处理
    */
    context === null ? (context = window) : null
    if (!/^(object|function)$/.test(typeof context)) context = Object(context)
    let self = this,
      key = Symbol('KEY'),
      result
    context[key] = self
    result = context[key](...params)
    delete context[key]
    return result
  }
  Function.prototype.change = change
})()
```

## 3.实现 bind

bind、call、apply

- 都是为了改变函数中的 this 指向
- call、apply：立即把函数执行
- bind：不是立即把函数执行，只是预先把 this 和后期需要传递的参数存储起来（预处理思想 -> 柯里化函数）

```js
~(function () {
  function bind() {}
  Function.prototype.bind = bind
})()
var obj = { name: 'Jhon' }
function func() {
  console.log(this, arguments)
  // 当点击body的时候，执行func方法，输出：obj [100,200,MouseEvent事件对象]
}
document.body.onclick = func.bind(obj, 100, 200)
```

bind原理：利用闭包的机制，把要执行的函数外面包裹一层函数

```js
~(function () {
  function bind(context, ...params) {
    /*
    this -> func
    context -> obj
    params -> [100,200]
    */
    let self = this
    return function proxy(...args) {
      // args -> 事件触发传递的信息，例如：ev
      params = params.concat(args)
      return self.call(context, ...params)
    }
  }
  Function.prototype.bind = bind
})()
```

## 4.call深度理解

```js
Function.prototype.call = function call(context, ...params) {
  let key = Symbol('KEY'),
    result
  context[key] = this
  result = context[key](...params)
  delete context[key]
  return result
} 
```

`A.call(B, x, y)`

- 最后 A 执行，this -> B，传递 x、y

`A.call.call(B, x, y)`

- A.call 先执行，this -> B，传递 x、y

- 再把 A.call 也就是 call 方法执行

  this -> B，context -> x，params -> y

  x.key = B

  x.key(y)

  最终的效果：让 B 执行，让 x 成为它的 this，传递一个值 y

```js
var name = 'Jhon'
function A(x, y) {
  var res = x + y
  console.log(res, this.name)
}
function B(x, y) {
  var res = x - y
  console.log(res, this.name)
}
// B基于__proto__找到Function.prototype.call方法，让call方法执行，B中的this是A，传递40、30
// this->A context->A params->40、30
B.call(A, 40, 30) // 10 'A'

// 让B.call.call执行，this->A，传递20、10。B.call.call(20, 10)
// 让B.call执行，this->20,传递10，B.call(10)
// 20[key]=A context->20 params->10
B.call.call.call(A, 20, 10) // NaN undefined
B.call.call(A, 20, 10) // NaN undefined

// Function.prototype匿名空函数，最后一个call执行，让其内部this->A 匿名空函数执行没有输出
Function.prototype.call(A, 60, 50)

Function.prototype.call.call.call(A, 80, 70) // NaN undefined
```

![](https://gitee.com/lilyn/pic/raw/master/js-img/call%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3.jpg)
