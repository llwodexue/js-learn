## 原型重定向

纯粹对象：创建的是 Object 的实例 `对象.__proto__ === Object.prototype `

```js
function fun() {
  this.a = 0
  this.b = function () {
    alert(this.a)
  }
}
fun.prototype = {
  b: function () {
    this.a = 20
    alert(this.a)
  },
  c: function () {
    this.a = 30
    alert(this.a)
  },
}
var my_fun = new fun()
my_fun.b()
my_fun.c()
```

**构造函数（原型重定向）**

应用场景：批量给构造函数的原型对象上扩充方法

1. 逐一向原型对象上扩充属性和方法

   麻烦、不聚焦（代码分散开）

   ```js
   let proto = fun.prototype
   proto.b = function () {}
   // ...
   proto.c = function () {}
   ```

2. 原型重定向

   问题：重定向之后，原始浏览器开辟的原型对象可能会被销毁，这样导致原始对象上的属性和方法会被清除（包含 constrctor）

   ```js
   func.prototype = {
     b: function () {},
     c: function () {},
   }
   ```

原型重定向解决方法：

1. 如果我们知晓原始原型对象上除了 constructor 没有其余的属性和方法，我们只需要在重定向的原型对象上自己手动设置 constructor 即可

2. 如果我们确定或者不确定原始对象上是否存在其余的属性和方法，我们此时需要把原始对象上的内容 copy 一份，重新赋值给新的原型对象（对象合并处理）

   `Object.assign([obj1], [obj2], ...)`：两个或者多个对象进行浅合（右侧替换左侧）

   - 注意：并没有返回全新的一个合并后的对象，返回的值依然是 obj1 这个堆，只是把 obj2 中的内容都合并到 obj1

   ```js
   function func() {}
   func.prototype.x = 100
   func.prototype.getX = function () {}
   func.prototype = Object.assign(func.prototype, {
     b: function () {},
     c: function () {},
   })
   ```

3. 内置类的原型是不允许重定向的，目的是保证这些内置属性/方法不丢失

   例如：`Array.prototype = {}` 不报错，但是没有任何效果

   虽然不允许重定向，但是可以把内置类原型上的某些方法进行单一的重写

   例如：`Array.prototype.push = function () {}` push 方法被重写

基于内置类原型扩展方法：

- 内置类的原型上，虽然提供很多供其实例调取的属性和方法，但是不一定能完全满足我们的需求，此时我们需要向内置类的原型上扩充方法

```js
let arr = [1, 2, 1, 2]

Array.prototype.unique = function unique() {
  // this -> arr，一般都是当前要操作的实例
  return Array.from(new Set(this))
}
```

- 好处：使用起来方便（`实例.方法`）；可以实现链式写法（核心：函数执行的返回值如果是某个类的实例，则可以直接继续调用这个类原型上的其他方法）
- 弊端：自己写的方法容易覆盖内置的方法（所以起名字最好设置前缀）

```js
// 向Number.prototype扩充方法
;(function (proto) {
  const verification = function verification(num) {
    num = +num
    return isNaN(num) ? 0 : num
  }
  const plus = function plus(num) {
    // this->要操作的数字（对象类型）
    let self = this
    num = verification(num)
    return self + num
  }
  const minus = function minus(num) {
    let self = this
    num = verification(num)
    return self - num
  }
  proto.plus = plus
  proto.minus = minus
})(Number.prototype)

let n = 10
let m = n.plus(10).minus(5)
console.log(m)
```

