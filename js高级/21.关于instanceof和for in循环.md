## instanceof

创建值有两种方案：

- 字面量方案
- 构造函数方案

```js
let n1 = 10 // Number类的实例[原始值]
let n2 = new Number(10) // Number类的实例[对象]
console.log(n1.toFixed(2)) // 10.00 // 内部处理机制"装箱和拆箱"：10->Object(10)
console.log(n2 + 10) // 20 // n2对象Symbol.toPrimitive/valueOf
console.log(n1 instanceof Number) // false // instanceof不能识别原始值
```

instanceof：检测某个实例是否属于这个类

## hasPubProperty

**面试题：自己编写一个方法 hasPubProperty 检测某个属性是否为对象的公有属性**

- `obj.hasOwnProperty([attr])` ：检测 attr 是否是 obj 对象的私有属性
- `[attr] in obj` ：检测 attr 是否为 obj 的一个属性（不论私有还是公有）

```js
function Fn(x, y) {
  let total = x + y,
    flag = false
  this.total = total
  this.say = function say() {
    console.log(this.total)
  }
}

let result = new Fn(10, 20)

function hasPubProperty(obj, attr) {
  /*
  基于in检测结果是true[是它的一个属性]
  基于hasOwnProperty检测结果是false[不是私有的],一定是公有属性
  */
  return attr in obj && !obj.hasOwnProperty(attr)
}
console.log(hasPubProperty(result, 'hasOwnProperty'))
console.log(hasPubProperty(result, 'say'))
```

弊端：只能检测某个属性不是私有的而是公有的，但是如果这个属性私有中也有公有中也有，基于这个方法结果是 false，但是这个属性确实也是它的公有属性

## for in

- for 循环遍历数组在或类数组
- for in 循环遍历对象

```js
let arr = [10, 20, 30]
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i], i)
}
for (let key in arr) {
  console.log(arr[key], i)
}
```

for 循环的本质不是遍历数组，是自己控制一个循环的逻辑

- `"i=0; i<3; i++"`
- 每一轮循环 i 的值，恰好是我们想获取当前数组中这一项的索引[i 从零开始，数组索引也是从零开始]，所以再基于成员访问获取即可

for in 本质是迭代对象，按照本身的键值对一一迭代，不过有一些缺陷：

- 不能遍历 Symbol 属性
- 迭代的时候不一定按照自己编写的键值对顺序迭代【优先迭代数字属性（小->大）】，再去迭代非数字属性【自己编写的顺序】
- 不仅会迭代对象的私有属性，对于一些自己扩展的 公有属性也会迭代到【迭代可枚举的（一般设定的都是可枚举的，内置的是不可枚举的）】

```js
Object.prototype.sum = function sum() {}
let obj = {
  name: 'bird',
  age: 12,
  0: 100,
  1: 200,
  [Symbol('AA')]: 300,
}
/* for (let key in obj) {
  console.log(key, obj[key])
} */
/*
0 100
1 200
name bird
age 12
sum [Function: sum]
*/
// 只是不想迭代公有的[即使内部机制找到了，我们也不让其做任何处理]
for (let key in obj) {
  if (!obj.hasOwnProperty(key)) break
  console.log(key, obj[key])
}
```

`Object.getOwnPropertySymbols(obj)` ：获取对象所有 Symbol 的私有属性【数组】

`Object.keys(obj) || Object.getOwnPropertyNames(obj)` ：获取对象所有非 Symbol 的私有属性【数组】

```js
function each(obj, callback) {
  let keys = Object.keys(obj),
    key = null,
    value = null,
    i = 0,
    len = 0
  if (typeof Symbol !== 'undefined') {
    // 支持Symbol
    keys = keys.concat(Object.getOwnPropertySymbols(obj))
  }
  len = keys.length
  if (typeof callback !== 'function') callback = function () {}
  for (; i < len; i++) {
    key = keys[i]
    value = obj[key]
    callback(value, key)
  }
}
each(obj, (value, key) => {
  console.log(value, key)
})
```

