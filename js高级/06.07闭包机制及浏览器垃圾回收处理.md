## 闭包

**函数执行的上级上下文和函数在哪执行无关，只和它在哪创建有关**

```js
/*
 * EC(G)
 *   i=0
 *   A=0x000A [[scope]]:EC(G)
 *   y=0x000X
 *   B=0x000B [[scope]]:EC(G)
 */
var i = 0;

function A() {
    /*
     * EC(A1)
     *   作用域链:<EC(A1),EC(G)>  
     *   形参赋值:--
     * i=10
     * x=0x000X [[scope]]:EC(A1)
     */
    var i = 10;

    function x() {
        /*
         * EC(X1)
         *   作用域链:<EC(X1),EC(A1)>
         *   形参赋值:-- 
         */
        /*
         * EC(X2)
         *   作用域链:<EC(X2),EC(A1)>
         *   形参赋值:-- 
         */
        console.log(i); //->10 10
    }
    return x;
}
var y = A();
y();

function B() {
    /* 
     * EC(B1)
     *   作用域链:<EC(B1),EC(G)>
     *   形参赋值:--
     * i=20
     */
    var i = 20;
    y();
}
B();
```

函数执行，产生一个私有的上下文，然后进栈

1. 当函数执行完，一般情况下，当前形成的上下文都会被栈释放掉【优化栈内存】：上下文被释放，之前存储的私有变量等也会被释放
2. 但是如果当前上下文中的某些东西【一般是堆内存】，被当前上下文以外的事物所占用，则当前上下文不能出栈释放。之前声明的私有变量也都被存储起来

**闭包：是一种机制，函数执行产生的私有上下文，一方面可以保护里面的私有变量不被污染，另一方面不能被释放，私有的变量及相关信息也都会保存起来**，我们把这种 **保护+保存** 的机制

```js
let x = 5;
function fn(x) {
    // 首先创建一个函数，把函数的堆内存地址当作返回值返回
    return function (y) {
        console.log(y + ++x);
    };
}
let f = fn(6);
f(7); // 7 + ++6=14
// 先把fn执行，执行的返回结果紧接着再次执行
fn(8)(9); // 8 + ++9=18
f(10); // 10 + ++7=18
console.log(x); // 5
```

## 闭包释放问题

堆内存释放问题：如果当前的堆被占用了【地址被引用，则不能释放，如果不被引用，浏览器会在空闲的时候释放它】

- 引用计数【被占用一次累加1，当取消运算再减去1，当减到0的时候，会把其释放掉】
- 引用检测，标记清除【被占用后做一个标记，当移除引用，取消标记，在浏览器空闲的时候，会把所有未被标记的内存回收】

`f=null` 【空对象指针，不开辟任何的位置，可用于释放空间】

```js
let a = 0,
    b = 0;
function A(a) {
    A = function (b) { // A不是私有的，是EC(G)中的
        console.log(a + b++);
    }; // 把全局A进行重构（重新赋值） 执行完后不释放，形参闭包
    console.log(a++);
}
A(1); // 1 + 0++=1; a->1++=2
A(2); // 2 + 2++=4; b->2++=3
```

