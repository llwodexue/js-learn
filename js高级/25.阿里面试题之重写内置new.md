## 重写 new

new 原理：

1. 创建Ctor的一个实例对象

   `实例.__proto__ = Ctor.prototype`

2. 把构造函数当做普通函数执行（让方法中的 this -> 实例对象）

3. 确认方法的返回值（如果没有返回值或者返回的是原始值，我们让其默认返回实例对象即可）

需要考虑的点：

- Symbol、BigInt 不能被 new

  我们知道 instanceof 是不能检测基本数据类型的 `Symbol() instanceof Symbol` 是 false。不过可以利用 call 方法来强迫装箱：当然这个也是 Function 和 Object 的实例

  注意：使用 `Object.prototype.toString.call(f)` 也是 symbol，因为会先去找 `Symbol.toStringTag` 这个属性（返回的是 `'[object Symbol]'`），所以需要结合 typeof 来区分（进行了装箱操作把基本数据类型转换为对应的引用数据类型）

  ```js
  let f = function () { return this }.call(Symbol(''))
  f instanceof Symbol // true
  
  Object.prototype.toString.call(f) // '[object Symbol]'
  typeof f // 'object'
  ```

  生成器函数不需要基于 new 执行，就可以创造函数实例。其实相当于内部做了 `f.__proto__ = fn.prototype` 的处理

  ```js
  function* fn() {}
  let f = fn()
  f instanceof fn // true
  ```

- 箭头函数不能被 new

  箭头函数没有 this，this 继承的是外层代码块的 this（也不能用 call 方法改变 this）

  箭头函数不能使用 arguments，不过可以使用 rest 运算符

  箭头函数不能使用 yield，箭头函数不能用作 Generator 函数

```js
function Dog(name) {
  this.name = name
}

Dog.prototype.bark = function () {
  console.log('wangwang')
}
Dog.prototype.sayName = function () {
  console.log('my name is ' + this.name)
}

/*
Ctor -> constructor缩写（构造函数）
params -> 后期给Ctor传递的所有实参信息
*/
function _new(Ctor, ...params) {
  let obj,
    result,
    proto = Ctor.prototype
  // 校验规则
  if (Ctor === Symbol || Ctor === BigInt || typeof Ctor !== 'function' || !proto)
    throw new TypeError(`${Ctor} is not a constructor`)
  obj = Object.create(Ctor.prototype)
  result = Ctor.call(obj, ...params)
  if (/^(object|function)$/.test(typeof result)) return result
  return obj
}

// let bear = new Dog('比尔')
let bear = _new(Dog, '比尔')
bear.bark() // wangwang
bear.sayName() // my name  is 比尔
console.log(bear instanceof Dog) // true
```

## 重写 `Object.create()`

`Object.create([obj])`：创建一个空对象，并让 `空对象.__proto__` 指向 `[obj]`

- `[obj]` 可以是一个对象或者是 null，但不能是其他的值
- `Object.create(null)` 创建一个不具备 `__proto__` 属性的对象（不是任何类的实例）

```js
Object.create = function create(prototype) {
  if (prototype !== null || typeof prototype !== 'object') throw new TypeError('Object prototype may only be')
  function Proxy() {}
  Proxy.prototype = prototype
  return new Proxy()
}
// 如果传null是无法删除 obj.__proto__ 的
```

