## let / const

- let 声明的变量
- const 声明的也是变量[只不过不允许重定向变量的指针，不能重新赋值]

```js
const y = 10;
y = 20; // Uncaught TypeError:Assignment to constant variable

const obj = {
  name:'Bird'
};
// const 声明的变量，只是不能重定向其指针指向其他值，但是不代表这个被指向的值本身不能变
obj.name = 'Dog';
console.log(obj);//{name:'Dog'}
```

## var / let 

JS 代码执行

- 语法解析（AST）：基于 HTTP 从服务器拉取回来的 JS 代码其实是一些字符串，浏览器首先会按照 ECMAScript 规则，把字符串变为 C++ 可以识别和解析的一套树结构对象
- 词法解析阶段，发现有在相同上下文中，基于 let 重复声明变量的操作，则直接报错，所有代码都不会执行

区别：

1. let 不存在变量提升

```js
console.log(x); // undefined
var x = 10;

console.log(y); // Uncaught ReferenceError:Cannot access 'y' before initialzation
let y = 20;
```

2. let 不允许重复声明 [在当前上下文中，不论基于什么方式声明了这个变量，再次基于 let / const 声明都会报重复声明错误]

```
// Uncaught SyntaxError:Identifier 'x' has already been declared
var x = 10;
let x = 10;
```

3. 全局上下文中，基于 var 声明的变量不存存放到 VO(G)中，而是直接放在 GO(window)中，基于 let 声明的变量是存放到 VO(G)中的

```js
debugger

var x = 10
console.log(x) // 10
/*
全局上下文查找一个变量：
  1.先找VO(G)中是否存在，如果存在就用这个全局变量
  2.如果VO(G)中没有，则再次尝试GO(window)中找[因为JS中某些操作是可以省略window]，如果有就是获取某个属性的值
  3.如果再没有，则直接报错：xxx is not defined
*/
console.log(window.x) // 10

let y = 10
console.log(y) // 10
console.log(window.y) // undefined
```

4. 暂时性死区

```js
console.log(typeof x) // Uncaught ReferenceError:Cannot access 'x' before initialzation
let x = 10
```

5. 块级作用域

   ES6之前，作用域只有两种：全局上下文、函数执行的私有上下文。有了 let 之后，产生了第三种：块级作用域[如果在`{}`(排除函数和对象的大括号)中出现 let/const/function，则当前的 `{}` 会成为一个块级私有上下文]

```js
/*
EC(G)
  GO -> x:10
  VO(G) -> y=20
  变量提升：var x
*/
var x = 10
let y = 20
if (true) {
  /*
  EC(BLOCK)
    VO(BLOCK)
    作用域链：<EC (BLOCK),EC(G)>
    没有this：this使用其上级上下文中额this[类似：箭头函数]
    没有arguments
    没有形参
    变量提升：[var是不受块级上下文影响]
  */
  var x = 100 // 操作的是全局的x
  let y = 200 // 属于EC(BLOCK)
  console.log(x, y) // 100 200
}
console.log(x, y) // 100 20
```

- 块级上下文的个数

```js
/*
产生6个块级上下文
  父级块级上下文[控制循环]
  第一轮循环产生一个块级上下文
*/
for (let i = 0; i < 5; i++) {}
console.log(i) //Uncaught ReferenceError:i is not defined

let arr = [10, 20, 30]
let i = 0,
  len = arr.length
// 不会产生块级上下文，性能更优
for (; i < len; i++) {}
```

- 循环绑定事件

  循环干的事情：循环五次，分别给五个按钮的点击行为绑定五个方法；循环结束，此时全局的 i=5

  点击的时候，执行绑定的函数[私有上下文]，在上下文中遇到变量 i，但是 i 不是自己私有的，找全局的，也就是 5

解决方案1：闭包机制

```js
let buttons = document.querySelectorAll('button')
for (var i = 0; i < buttons.length; i++) {
  // 每一轮循环都创建一个私有的上下文
  (function (i) {
    buttons[i].onclick = function () {
      // 每一轮循环的私有上下文中，创建的小函数被上下文以外的buttons某一个onClick占用，产生闭包
      alert(i)
    }
  })(i)
}

for (var i = 0; i < buttons.length; i++) {
  // 每一轮循环都创建一个私有的上下文
  buttons[i].onclick = (function (i) {
    return function () {
      alert(i)
    }
  })(i)
}

for (let i = 0; i < buttons.length; i++) {
  // 每一轮循环都创建一个私有的上下文
  buttons[i].onclick = function () {
    alert(i)
  }
}
```

解决方案2：自定义属性

```js
let buttons = document.querySelectorAll('button'),
  i = 0,
  len = buttons.length
for (; i < len; i++) {
  // 设置自定义属性index存储按钮的索引
  buttons[i].index = i
  buttons[i].onclick = function () {
    // this->当前点击的元素
    alert(this.index)
  }
```

解决方案3：事件委托。性能提高40%-60%

```js
document.body.onclick = function (ev) {
  let target = ev.target
  // 点击的是button按钮
  if (target.tagName === 'BUTTON') {
    // 基于事先在结构上自定义属性获取其索引即可
    alert(target.getAttribute('index'))
  }
}
```

