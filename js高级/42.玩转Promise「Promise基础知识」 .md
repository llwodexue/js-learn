## JS 中的异步任务

JS 是单线程的：大部分代码都是同步的，但是也有少部分代码是异步编程的

**异步宏任务**

- 定时器
- ajax：一般都是异步的（单独开一个线程，http 宏任务）
- 事件绑定（DOM 事件监听线程）

**异步微任务**

- promise
- async await
- generator
- window.requestAnimationFrame
- ...

## Promise

承诺者模式，ES6 新增的一个内置类

### Promise 执行

```js
let p = new Promise() // TypeError: Promise resolver undefined is not a function
```

`let p = new Promise([executor])` 

- `[executor]`：可执行函数

  `new Promise` 的时候，在 Promise 内部会立即把 `[executor]` 函数执行

  函数中一般用来管理异步编程代码（不管控异步编程也可以）

  同时给 `[executor]` 函数传递两个值（函数类型）：resolve/reject

- p 是 Promise 类的一个实例

  内置私有属性

  - `[[PromiseState]]` 实例状态：pending 等待态、fulfilled/resolved 成功态、rejected 失败态
  - `[[PromiseResult]]` 实例的值

  公共属性方法 `Promise.prototype`

  - `catch`
  - `finally`
  - `then`
  - `Symbol(Symbol.toStringTag): "Promise"`

### Promise 的回调函数

```js
let p = new Promise((resolve, reject) => {
  resolve('OK')
  // reject('NO')
})
p.then(result => {
  console.log('成功', result)
})
console.log(p)
```

在 `[executor]` 执行 `resolve/reject` 都是为了改变 Promise 实例的状态和值【结果】

- 一旦状态被改变成 `fulfilled/rejected` 则不能再改为其他的状态

  `resolve('OK')` ：`[[PromiseState]]: fulfilled [[PromiseResult]]: 'OK'`

  `reject('NO')` ：`[[PromiseState]]: rejected [[PromiseResult]]: 'NO'`

- 如果 `[executor]` 函数执行报错，则

  `[[PromiseState]]: rejected [[PromiseResult]]: 报错原因`

  Promise 内部做了异常捕获（try catch）

执行 `p.then(onfulfilledCallback, onrejectedCallback)`

- 首先把传递进来的 onfulfilledCallback 和 onrejectedCallback 存储起来（存储在一个容器中：因为可以基于 then 给其存多个回调函数）

- 再次去验证当前实例的状态

  如果实例状态是 pending，则不做任何处理

  如果已经变为 fulfilled/rejected，则会通知对应对应的回调函数执行（不是立即执行，而是把其放置在 EventQueue 中的微任务队列中）

```js
let p = new Promise((resolve, reject) => {
  console.log(1)
  setTimeout(() => {
    resolve('OK')
    // 改变实例的状态和值【同步】
    // 通知之前基于then存放的onfulfilledCallback执行【异步微任务：也就是把执行方法的事情放置在EventQueue中的微任务队列中】
    console.log(4)
  }, 1000)
  console.log(2)
})
// 此时接收onfulfilledCallback的时候，状态还是pending，此时只是把方法存储起来
p.then(result => {
  console.log('成功', result)
})
console.log(3)
// 等1000ms后，执行定时器中的函数【把异步宏任务拿出来执行】
```

总结：**Promise 本身不是异步的，是用来管理异步的，但是 then 方法是异步的（微任务）**

