## 类三大特性

JS 本身是基于面向对象开发的编程语言。类：封装、继承、多态

- 封装：类是一个函数，把实现一个功能的代码进行封装，以此实现 "低耦合高内聚"

- 多态：重载、重写

  重写：子类重写父类上的方法（伴随着继承运行）

  重载：相同的方法，由于参数或返回值不同，具备了不同的功能（JS 中不具备严格意义的重载；JS 中的重载，同一个方法内，根据传参不同实现不同的功能）

  ```typescript
  // 函数重载（两个函数名称相同，参数个数/类型不同）
  function add(...rest: number[]): number
  function add(...rest: string[]): string
  function add(...rest: any[]): any {
    let first = rest[0]
    if (typeof first === 'string') {
      return rest.join('')
    }
    if (typeof first === 'number') {
      return rest.reduce((pre, cur) => pre + cur)
    }
  }
  ```

- 继承：子类继承父类的方法

  其它语言的继承跟生活中的继承很相似，子基因修改了但不会影响父（单独拷贝一份）

## 继承

继承的目的：让子类的实例同时也具备父类中私有的属性和公共的方法

### 原型继承

子类的原型等于父类的实例

- 子类的实例，能够用子类私有的和原型上公有的
- 父类的实例，可以使用父类私有和原型上公有的

原型继承：

1. 父类中私有和公有的属性方法，最后都变为子类实例公有的
2. 和其它语言不同的是，原型链并不会把父类的属性方法，"拷贝"给子类，而是让子类实例基于 `__proto__` 原型链找到自己定义的属性和方法（"指向/查找"）

```js
function Parent() {
  this.x = 100
}
Parent.prototype.getX = function getX() {
  return this.x
}

function Child() {
  this.y = 200
}
Child.prototype = new Parent() // 原型继承
Child.prototype.getY = function getY() {
  return this.y
}

let c1 = new Child()
console.log(c1)
// c1.__proto__.xxx=xxx 修改子类原型（原有父类的一个实例）中的内容，内容被修改后，对子类的其它实例有影响，但是对父类的实例不会有影响
// c1.__proto__.__proto__.xxx=xxx 直接修改的是父类原型，这样不仅会影响其它父类的实例，也影响其它子类的实例
```

![](https://gitee.com/lilyn/pic/raw/master/js-img/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BFZ.jpg)

### call 继承

call 继承：

- 只能继承父类中私有的，不能继承父类中公有的

```js
function Parent() {
  this.x = 100
}
Parent.prototype.getX = function getX() {
  return this.x
}

function Child() {
  // 在子类构造函数中，把父类当做普通方法执行（没有父类实例，父类原型上的那些东西也就和它没关系了）
  // this -> Child实例c1
  Parent.call(this) // this.x=100相当于强制给c1实例设置一个私有的属性x，属性值100，相当于让子类的实例继承了父类的私有属性，并且也变为子类私有属性 "拷贝式"
  this.y = 200
}
Child.prototype.getY = function getY() {
  return this.y
}

let c1 = new Child()
console.log(c1)
```

### 寄生组合式继承（call继承 + 原型继承）

```js
function Parent() {
  this.x = 100
}
Parent.prototype.getX = function getX() {
  return this.x
}

function Child() {
  Parent.call(this)
  this.y = 200
}
// Child.prototype.__proto__ = Parent.prototype
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
Child.prototype.getY = function getY() {
  return this.y
}

let c1 = new Child()
console.log(c1)
```

![](https://gitee.com/lilyn/pic/raw/master/js-img/%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BFZ.jpg)

### 类继承

```js
class Parent {
  constructor() {
    this.x = 100
  }
  // Parent.prototype.getX=function...
  getX() {
    return this.x
  }
}

// 注意：继承后一定要在constructor加上super
class Child extends Parent {
  constructor() {
    super() // 类似call继承
    this.y = 200
  }
  getY() {
    return this.y
  }
}
// Child() // TypeError: Class constructor Child cannot be invoked without 'new ES6中创建的就是类，不能当做普通函数执行，只能new执行

let c1 = new Child()
console.log(c1)
```

