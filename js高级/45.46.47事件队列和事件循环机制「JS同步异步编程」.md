## JS 同异步线程

浏览器是多线程【同时做多件事情】

- GUI 渲染线程
- JS 引擎线程【渲染解析 JS 的】
- DOM/定时器监听等线程
- HTTP 网络线程

JS 是单线程的

- 情况：同时只能处理一件事情【上面代码没有执行完，下面代码是不能执行的】 -> "同步编程"

JS 中部分操作是异步编程

- 但是绝对不是类似于多线程开发中的同时做多件事情，它一次只能处理一件事，因为是单线程；如果 "JS 引擎线程" 正在解析  JS 代码，处理某个任务，那么其它什么事情都处理不了
- 浏览器基于 EventQueue 事件队列、EventLoop 事件循环两大机制，构建出 "异步编程的效果" -> 单线程异步操作

异步宏任务：

- 定时器
- DOM 事件
- HTTP 请求（ajax、fetch、jsonp...）
- ...

异步微任务：

- promise 【resolve、reject、then...】
- async await
- requestAnimationFrame
- ...

## 事件循环机制

浏览器加载页面的时候会形成一个事件队列（Event Queue），它是一个优先级队列，分为微任务（microtask）和宏任务（macrotask）

代码自上而下执行，将未来要执行的任务放在事件队列中，等待主线程代码都执行再执行

主线程把同步任务都执行完，主线程空闲下来，开始到事件队列中，找所有的异步任务

- 先找异步微任务的事件，如果有需要执行的拿出来执行，直到微任务中没有需要只执行的，则去异步宏任务去找

  注意：如果执行 then 的时候就知道实例状态，它会在未来直接把 onfulfilledCallback 执行【不存储了】

  不知道实例状态，才是把方法存储起来【因为之前执行 resolve 也建立了一个微任务，就是把存储的方法后期执行】

- 如果有多个任务都符合了可执行条件，则谁先达到执行阶段的，就把谁先执行

- 把需要执行的异步任务拿到执行环境栈中，让主线程去执行

定时器事件到时间不一定被执行，因为 JS 是单线程，必须等待主线程空闲才有时间执行异步任务，所以定时器的时间是不准确的（动画能有 CSS3 实现就尽量用 CSS3 实现，如果实现不了再用 requestAnimationFrame）

![定时器谁先到达执行阶段，就把谁先执行](https://gitee.com/lilyn/pic/raw/master/js-img/%E5%AE%9A%E6%97%B6%E5%99%A8%E8%B0%81%E5%85%88%E5%88%B0%E8%BE%BE%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%EF%BC%8C%E5%B0%B1%E6%8A%8A%E8%B0%81%E5%85%88%E6%89%A7%E8%A1%8C.jpg)

```js
setTimeout(() => {
  console.log(1)
}, 1000)
/* 设置一个定时器，设定 等待时间【同步立即处理】 
到达时间后，把会滴函数触发执行【任务1：开始计时，到达1000ms后，通知主线程去把回调函数执行】*/
console.log(2)
new Promise(resolve => {
  /* new Promise的时候会立即执行回调函数executor */
  console.log(3)
  /* 立即把promise实例的状态改为fulfilled【任务2：能够把后期基于then存进来的方法onfulfilledCallback通知执行（前提：方法还没有被执行）】 */
  resolve()
  console.log(4)
})
  .then(() => {
    /* 创建一个新的promise实例【实例状态由传入的方法执行是否报错或是否返回新的promise实例等因素决定】
    - 如果已经知道的实例状态，此时会决定onfulfilledCallback这个方法执行【异步任务3：哪怕状态成功的，也不是立即执行】 
    - 如果不知道实例的状态，只把方法存储起来*/
    console.log(5)
  })
  .then(() => {
    /* 任务4：等待上一个onfulfilledCallback执行，知道状态后，再次执行这次基于then存放的方法 */
    console.log(6)
  })
console.log(7)
const fn = () => {
  console.log(9)
}
;(async function () {
  console.log(8)
  /* 立即把fn执行【了解其是否成功】任务5：当前上下文，await下面的代码是一个新的异步任务，等到await后面的结果是一个成功的promise实例，才会执行下面的代码 */
  await fn()
  console.log(10)
  await fn()
  console.log(11)
})()
/* 同步任务执行完，主线程空闲下来，开始执行异步任务（如果同步任务没有执行完，也就是主线程没有空闲下来，不论异步任务是否到达了可执行阶段，都不能执行。因为JS是单线程，不能同时做多个事情） */
console.log(12)
/* 
2 3 4 7 8 9 12 5 10 9 6 11 1
*/
```

## 同异步练习题
