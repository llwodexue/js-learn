# Vue 基础

## Vue 实例

每个 Vue 应用都是通过 `Vue` 函数创建一个新的 Vue 实例 开始的：

```js
var vm = new Vue({
  // 选项
})
```

使用 `Object.freeze`（冻结一个对象），会阻止修改现有的 property，也意味着响应系统无法再追踪变化

```js
var obj = {
  foo: 'bar'
}
Object.freeze(obj)
new Vue({
  el: '#app',
  data: obj
})
```

实例生命周期钩子

| 生命周期钩子         | vue           | React                |
| -------------------- | ------------- | -------------------- |
| 实例创建前           | beforeCreate  | ---                  |
| 实例创建后           | created       | constructor()        |
| DOM挂载前            | beforeMount   | componentWillMount   |
| DOM挂载后            | mounted       | componentDidMount    |
| 数据更新时           | beforeUpdate  | componentWillUpdate  |
| 数据更新后           | updated       | componentDidUpdate   |
| keep-alive组件激活时 | activated     | ---                  |
| keep-alive组件停用时 | deactivated   | ---                  |
| 实例销毁前           | beforeDestroy | componentWillUnmount |
| 实例销毁后           | destroyed     | componentWillUnmount |
| 子组件发送错误时     | errorCaptured |                      |

## 模板语法

数据绑定最常见的形式就是使用 "Mustache" 语法（双大括号）的文本插值：

```html
<span>Message: {{ msg }}</span>
```

Vue.js 提供了完全的 JavaScript 表达式支持：简单的运算符、三元表达式、链式调用都可以

```html
{{ number + 1 }}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
<div v-bind:id="'list-' + id"></div>
```

## 条件、列表渲染

Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染

- 例如：如果你允许用户在不同的登录方式之前切换，那么输入框中的内容不会被替换
- 这时只需要添加一个具有唯一值的 `key` attribute 即可

```html
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
```

`v-if` 和 `v-show` 区别：

- `v-if` 是"真正"的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。如果初始渲染时条件为假，则什么也不做
- `v-show`：不管初始条件是什么，元素总会被渲染被渲染，只是简单地基于 CSS 进行切换
- 一般来说 `v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销

`v-if` 和 `v-for` 一起使用：

- 当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` **更高的优先级**

  `v-if` 将分别重复运行在每个 `v-for` 循环中。当你指向为部分渲染节点时，可以利用这个优先级

```js
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo }}
</li>
```

`v-for` 遍历对象

- 在遍历对象时，会按 `Object.keys()` 的结果遍历

```html
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```

## 事件处理

使用修饰符时，顺序很重要：

-  `v-on:click.prevent.self` 会阻止所有的点击
-  `v-on:click.self.prevent` 只会阻止对元素自身的点击

**事件修饰符**

- `.stop`
- `.prevent`
- `.capture`
- `.self`
- `.once`
- `.passive`

**按键码**

- `.enter`
- `.tab`
- `.delete`
- `.esc`
- `.space`
- `.up`
- `.down`
- `.left`
- `.right`

**系统修饰键**

- `.ctrl`
- `.alt`
- `.shift`
- `.meta`

`.exact` 修饰符允许你控制由精确地系统修饰符组合触发的事件

```html
<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>
<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button v-on:click.exact="onClick">A</button>
```

**鼠标按钮修饰符**

- `.left`
- `.right`
- `.middle`

**值修饰符**

- `.lazy`
- `.number`
- `.trim`

## 组件基础

一个组件的 `data` 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：

```js
data: function () {
  return {
    count: 0
  }
}
```

在组件上，使用 `v-model`

```html
<custom-input
  v-bind:value="searchText"
  v-on:input="searchText = $event"
></custom-input>
```

- 将其 `value` attribute 绑定到一个名叫 `value` 的 prop 上
- 在其 `input` 事件被触发后，将新的值通过自定义的 `input` 事件抛出

# 深入了解组件

## 组件注册

定义组件名的方式有两种：

**使用 kebab-case**

- 使用 短横线分割命名 定义一个组件时，引用这个自定义组件时也是使用 短横线分割命名，例如：`<my-component-name>`

```js
Vue.component('my-component-name', { /* ... */ })
```

**使用 PascalCase**

- 使用 首字母大写命名 定义一个组件时，在引用这个自定义元素时两种命名法都可以使用

  也就是说：`<my-component-name>` 和 `MyComponentName` 都可以接受

```js
Vue.component('MyComponentName', { /* ... */ })
```

## Prop

所有的 prop 都使得其父子 prop 之间形成一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止子组件意外变更父组件的状态，从而导致你的应用的数据流向难以理解

1. **这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。** 在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：

   ```js
   props: ['initialCounter'],
   data: function () {
     return {
       counter: this.initialCounter
     }
   }
   ```

2. **这个 prop 以一种原始的值传入并且需要进行转换。** 在这种情况下，最好使用这个 prop 的值来定义一个计算属性

   ```js
   props: ['size'],
   computed: {
     normalizedSize: function () {
       return this.size.trim().toLowerCase()
     }
   }
   ```

**类型检查**

`type` 可以是一下原生构造函数中的一个：

- `String`
- `Number`
- `Boolean`
- `Array`
- `Object`
- `Date`
- `Function`
- `Symbol`

**禁用 Attribute 继承**

如果你不希望组件的根元素继承 attribute，你可以在最贱的选项中设置 `inheritAttrs: false`

- 有了 `inheritAttrs: false` 和 `$attrs`，你就可以手动决定这些 attribute 会被赋予哪个元素

```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on:input="$emit('input', $event.target.value)"
      >
    </label>
  `
})
```

