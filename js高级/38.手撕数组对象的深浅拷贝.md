## 浅拷贝

```js
let obj = {
  url: '/api/list',
  method: 'GET',
  headers: {
    'Content-Type': 'application/json',
    post: {
      'X-Token': 'xxx',
    },
  },
  cache: false,
  arr: [10, 20, 30],
  key: Symbol('key'),
  // big: 10n,
  n: null,
  u: undefined,
  reg: /^\d$/,
  time: new Date(),
  fn: function () {
    console.log(this)
  },
}
// obj.obj = obj

// 把对象进行克隆
let new_obj1 = Object.assign({}, obj)
let new_obj2 = { ...obj }
let new_obj3 = {}
_.each(obj, (value, key) => {
  new_obj[key] = value
})

// 把数组进行克隆 slice 扩展运算符
```

## 深拷贝

`JSON.parse(JSON.stringify(obj))`

- `JSON.stringify` ：把对象/数组变为 JSON 字符
- `JSON.parse` ：把 JSON 字符串变为对象/数组[浏览器需要重新开辟所有内存]

**问题：**

- 不允许出现套娃操作 `TypeError: Converting circular structure to JSON`
- 属性值不能是 bigInt `TypeError: Do not know how to serialize a BigInt`
- 丢失一些内容：属性是 Symbol/undefined/function 这些类型
- 信息不准确：RegExp对象->空对象；Date对象->字符串；Error对象->空对象

`Qs.parse(Qs.stringify(obj))`

- `Qs.stringify` ：把对象变为 urlencoded 格式字符串 `"xxx=xxx&xxx=xxx"`
- `Qs.parse` ：把 urlencoded 格式字符串变为对象

`new target.constructor(target)`

- 创建对应类型的类型值
- Symbol、BigInt 不能被 new

```js
/*
clone(obj)
clone(true, obj)
*/
var clone = function clone() {
  var target = arguments[0],
    deep = false,
    type,
    isArray,
    isObject,
    result,
    Ctor,
    treated = arguments[arguments.length - 1]
  !Array.isArray(treated) || !treated.treated ? ((treated = []), (treated.treated = true)) : null
  if (typeof target === 'boolean') {
    deep = target
    target = arguments[1]
  }
  // 防止死递归处理
  if (treated.indexOf(target) > -1) return target
  treated.push(target)
  type = toType(target)
  isArray = type === 'array'
  isObject = isPlainObject(target)
  // 特殊值的拷贝
  if (target == null) return target
  Ctor = target.constructor
  if (/^(regexp|date)$/i.test(type)) return new Ctor(target)
  if (/^error$/i.test(type)) return new Ctor(target.message)
  if (/^(function|generatorfunction)$/i.test(type)) {
    return function proxy() {
      var arg = Array.from(arguments)
      target.apply(this, arg)
    }
  }
  if (!isArray && isObject) return target
  // 如果是数组或对象，依次迭代赋值给新的数组/对象
  result = new Ctor()
  each(target, function (copy, name) {
    if (deep) {
      // 深拷贝
      result[name] = clone(deep, copy, treated)
      return
    }
    // 浅拷贝
    result[name] = copy
  })
  return result
}
```

