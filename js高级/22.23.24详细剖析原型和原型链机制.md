## 原型链

- 每一个类（函数）都具备 prototype，并且属性值是一个对象
- 对象上天生具备一个属性：constructor 指向类本身
- 每一个对象（普通对象、prototype、实例、函数等）都具备：`__proto__`，属性值是当前实例所属类的原型

### prototype

大部分 "函数数据类型" 的值都具备 prototype （原型或显式原型）属性，属性本身是一个对象

浏览器会为其默认开辟一个堆内存，用来存储当前类所属实例可以调用的公共的属性和方法，在浏览器默认开辟的堆内存中（原型对象）有一个默认属性 "constructor（构造函数或构造器）"，属性是当前函数/类本身

**函数数据类型**

- 普通函数（实名或匿名函数）
- 箭头函数
- 构造函数或类
- 生成器函数 Generator

**不具备 prototype 的函数**

- 箭头函数 `const fn = () => {}`
- 基于 ES6 给某个成员赋值函数值的快捷操作 

```js
let obj = {
  fn1: function () {},
  fn2() {},
}
console.dir(obj.fn1) // 有prototype
console.dir(obj.fn2) // 无prototype

class Fn {
  fn() {}
}
console.dir(Fn.prototype.fn)  // 无prototype
```

### `__proto__`

每一个 "对象数据类型" 的值都具备一个属性 `__proto__` （原型链或隐式原型），属性值指向 "自己所属类的原型 prototype"

所有对象都是 Object 类的实例，`Object.prototype.__proto__ === null`，Object 类是所有对象的 "基类"

**对象数据类型**

- 普通对象
- 特殊对象：Array、RegExp、Date、Math、Error...
- 函数对象
- 实例对象
- 构造函数.prototype

**成员访问（原型链 机制）**

- 首先访问自己的私有属性，如果私有属性中是存在的，则直接使用私有的
- 如果私有属性中没有，默认会基于 `__proto__` 找到所属类 `prototype` 上的属性和方法
- 如果所属类的 prototype 上也没有，则继续基于 `prototype.__proto__` 向上查找，一直找到 `Object.prototype` 为止

**forEach 方法执行**

- `arr.forEach`
- ``arr.__proto__.forEach()` 直接跳过私有的
- `Array.prototype.forEach()` 直接找原型上的

`__proto__` 一般不会自己手动操作（IE 浏览器把其保护起来，不允许我们访问）

### constructor

`实例.constructor` 一般是获取直属类的信息（值可以被修改，所以不一定准确）

### 例题

创造 Fn 类的实例：

- `new Fn()` 带参数，优先级 20
- `new Fn` 不带参数，优先级 19

```js
function Fn() {
  this.x = 100
  this.y = 200
  this.getX = function () {
    console.log(this.x)
  }
}
Fn.prototype.getX = function () {
  console.log(this.x)
}
Fn.prototype.getY = function () {
  console.log(this.y)
}
let f1 = new Fn()
let f2 = new Fn()
console.log(f1.getX === f2.getX) // false
console.log(f1.getY === f2.getY) // true
console.log(f1.__proto__.getY === Fn.prototype.getY) // true
console.log(f1.__proto__.getX === f2.getX) // false
console.log(f1.getX === Fn.prototype.getX) // false
console.log(f1.constructor) // Fn
console.log(Fn.prototype.__proto__.constructor) // Object
f1.getX() // 私有getX，this->f1；100
f1.__proto__.getX() // 原型getX，this->f1.__proto__；undefined
f2.getY() // 原型getY，this->f2；200
Fn.prototype.getY() // 原型getY，this->Fn.prototype；undefined
```

