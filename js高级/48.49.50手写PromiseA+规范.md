## 手写Promise

基于原生 JS 实现 Promise（遵循的是 Promise A Plus 规范）
[https://promisesaplus.com/](https://promisesaplus.com/)

回调函数：把一个函数 A 作为值，传递到另外一个执行的函数 B 中，在 B 中可以把 A 执行

- 执行 0 ~ N 次
- 改变函数中的 this
- 可以给回调函数传递参数
- 接收函数的返回值

Promise 原理：

1. 首先会给当前实例增加状态（默认是 pending 等待态）和两个事件池 成功的事件池和失败的事件池（用来存放 then 中还不知道实例状态的事件）

2. 其次最重要的就是 Promise 内部传递的 executor 函数，此函数会立即执行并会传递两个回调函数 resolve 和 reject，当执行任何一个回调函数时，都会做两件事情：**更改状态、发布对应事件池的状态方法** 

   注意：更改完状态就不能再更改了（是 pending 才会改状态）；执行回调函数时如果基于 then 存储过方法，依次通知对应状态的事件池方法执行，且执行是异步的微任务

3. new Promise 会创造实例，实例可以调用其所属类原型的方法，之后重构了一下 Promise 构造函数原型上的方法

需要注意的点：

- Promise 是一个构造函数，需要 new 执行
- Promise 参数必须是一个函数
- Promise then 里的方法实际上是异步的微任务，可以基于 queueMicrotask 去创造异步的微任务（兼容性差）；这里采用基于定时器创造一个异步的宏任务，来模拟微任务 

```js
;(function () {
  function Promise(executor) {
    var self = this,
      change
    // 必须new执行
    if (!(self instanceof Promise)) throw new TypeError('undefined is not a promise')
    // executor必须是一个函数
    if (typeof executor !== 'function') throw new TypeError('Promise resolver ' + executor + ' is not a function')

    // 实例具备的属性，状态和结果
    self.state = 'pending'
    self.result = undefined
    self.onFulfilledCallbacks = []
    self.onRejectedCallbacks = []

    // 修改实例的状态
    change = function change(state, result) {
      if (self.state !== 'pending') return
      self.state = state
      self.result = result
      // 创建异步微任务，通知集合中存储的方法执行（前提：集合中有东西才执行）
      var callbacks = state === 'fulfilled' ? self.onFulfilledCallbacks : self.onRejectedCallbacks,
        i = 0,
        len = callbacks.length,
        callback
      if (callbacks.length > 0) {
        setTimeout(function () {
          for (; i < len; i++) {
            callback = callbacks[i]
            if (typeof callback === 'function') callback(result)
          }
        }, 0)
      }
    }

    // new Promise的时候会立即执行executor函数
    try {
      executor(
        function resolve(result) {
          change('fulfilled', result)
        },
        function reject(reason) {
          change('rejected', reason)
        }
      )
    } catch (error) {
      // 执行executor报错，实例也是失败的状态
      change('rejected', error)
    }
  }

  // 验证是否为Promise
  function isPromise(x) {
    if (x == null) return false
    if (/^(object|function)$/i.test(typeof x)) {
      if (typeof x.then === 'function') {
        return true
      }
    }
    return false
  }

  // 处理onFulfilled/onRejected方法执行返回结果的处理
  function handle(promiseNew, x, resolve, reject) {
    if (x === promiseNew) throw new TypeError('TypeError: Chaining cycle detected for promise #<Promise>')
    if (isPromise(x)) {
      try {
        x.then(resolve, reject)
      } catch (err) {
        reject(err)
      }
      return
    }
    // 返回不是promise实例，而且执行没有报错，则promiseNew一定是成功的，x是它的结果
    resolve(x)
  }

  Promise.prototype = {
    constructor: Promise,
    self: true,
    then: function (onFulfilled, x, resolve, reject) {
      var self = this,
        promiseNew,
        x
      if (typeof onFulfilled !== 'function') {
        onFulfilled = function onFulfilled(result) {
          return result
        }
      }
      if (typeof onRejected !== 'function') {
        onRejected = function onRejected(reason) {
          reject(reason)
        }
      }
      promiseNew = new Promise(function (resolve, reject) {
        // resolve reject可以设置返回的@TP（新promise实例是成功还是失败以及结果等）
        // 但是执行哪个方法，由监听onFulfilled/onRejected方法报错以及返回值来决定
        // 情况1：如果已经知道对应实例的状态还是失败，则创建一个异步的微任务，后期执行对应的onFulfilled/onRejected
        // 情况2：如果此时还不知道实例状态，就先把onFulfilled/onRejected存储起来，后期更改其状态之后，再通知方法执行即可，也是异步微任务
        switch (self.state) {
          case 'fulfilled':
            setTimeout(function () {
              try {
                x = onFulfilled(self.result)
                handle(promiseNew, x, resolve, reject)
              } catch (err) {
                reject(err)
              }
            })
            break
          case 'rejected':
            setTimeout(function () {
              try {
                x = onRejected(self.result)
                handle(promiseNew, x, resolve, reject)
              } catch (err) {
                reject(err)
              }
            }, 0)
            break
          default:
            self.onFulfilledCallbacks.push(function (result) {
              try {
                x = onFulfilled(result)
                handle(promiseNew, x, resolve, reject)
              } catch (err) {
                reject(err)
              }
            })
            self.onRejectedCallbacks.push(function (reason) {
              try {
                x = onRejected(reason)
                handle(promiseNew, x, resolve, reject)
              } catch (err) {
                reject(err)
              }
            })
        }
      })
      return promiseNew
    },
    catch: function (onRejected) {
      return this.then(null, onRejected)
    },
  }
  if (typeof Symbol !== 'undefined') Promise.prototype[Symbol.toStringTag] = 'Promise'

  // 普通对象：私有静态方法
  Promise.all = function all() {}
  Promise.resolve = function resolve(result) {
    return new Promise(function (resolve) {
      resolve(result)
    })
  }
  Promise.reject = function reject(reason) {
    return new Promise(function (_, reject) {
      reject(reason)
    })
  }

  /* 暴露API */
  if (typeof window !== 'undefined') window.Promise = Promise
  // if (typeof module === 'object' && typeof module.exports === 'object') module.exports = Promise
})()

// 每一次执行then方法，都会返回一个全新的promise实例 @TP（then链）
// 状态：是由上一个then中传入的onFulfilled或者onRejected执行决定的
// 方法执行看返回值，如果返回的不是Promise实例，则方法执行不报错，新实例就是fulfilled，并且return的结果是新实例的结果，反之执行报错则认为新实例是失败的，结果是报错原因
// 如果返回的也是一个promise实例 @RP 这样的话，@RP的状态和结果直接影响了@TP的状态和结果
let p1 = new Promise(function (resolve, reject) {
  Math.random() < 0.5 ? resolve('OK') : reject('NO')
})
// try catch 一般情况下是无法捕捉到异步任务执行报错信息
let p2 = p1.then(
  function (result) {
    console.log('成功', result)
    return 200
  },
  function (reason) {
    console.log('失败', reason)
    return Promise.reject(500)
  }
)
let p3 = p2.then(
  function (result) {
    console.log('成功', result)
  },
  function (reason) {
    console.log('失败', reason)
  }
)
```

ES6 方法实现 Promise，可以参考我另外一篇文章 [手撕 Promise（内附then链实现）](https://blog.csdn.net/qq_38689395/article/details/114014869)

