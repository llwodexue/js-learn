## JS 中的异步任务

JS 是单线程的：大部分代码都是同步的，但是也有少部分代码是异步编程的

**异步宏任务**

- 定时器
- ajax：一般都是异步的（单独开一个线程，http 宏任务）
- 事件绑定（DOM 事件监听线程）

**异步微任务**

- promise
- async await
- generator
- window.requestAnimationFrame
- ...

## Promise

承诺者模式，ES6 新增的一个内置类

### Promise 执行

```js
let p = new Promise() // TypeError: Promise resolver undefined is not a function
```

`let p = new Promise([executor])` 

- `[executor]`：可执行函数

  `new Promise` 的时候，在 Promise 内部会立即把 `[executor]` 函数执行

  函数中一般用来管理异步编程代码（不管控异步编程也可以）

  同时给 `[executor]` 函数传递两个值（函数类型）：resolve/reject

- p 是 Promise 类的一个实例

  内置私有属性

  - `[[PromiseState]]` 实例状态：pending 等待态、fulfilled/resolved 成功态、rejected 失败态
  - `[[PromiseResult]]` 实例的值

  公共属性方法 `Promise.prototype`

  - `catch`
  - `finally`
  - `then`
  - `Symbol(Symbol.toStringTag): "Promise"`

### Promise 的回调函数

总结：**Promise 本身不是异步的，是用来管理异步的，但是 then 方法是异步的（微任务）**

```js
let p = new Promise((resolve, reject) => {
  resolve('OK')
  // reject('NO')
})
p.then(result => {
  console.log('成功', result)
})
console.log(p)
```

在 `[executor]` 执行 `resolve/reject` 都是为了改变 Promise 实例的状态和值【结果】

- 一旦状态被改变成 `fulfilled/rejected` 则不能再改为其他的状态

  `resolve('OK')` ：`[[PromiseState]]: fulfilled [[PromiseResult]]: 'OK'`

  `reject('NO')` ：`[[PromiseState]]: rejected [[PromiseResult]]: 'NO'`

- 如果 `[executor]` 函数执行报错，则

  `[[PromiseState]]: rejected [[PromiseResult]]: 报错原因`

  Promise 内部做了异常捕获（try catch）

执行 `p.then(onfulfilledCallback, onrejectedCallback)`

- 首先把传递进来的 onfulfilledCallback 和 onrejectedCallback 存储起来（存储在一个容器中：因为可以基于 then 给其存多个回调函数）

- 再次去验证当前实例的状态

  如果实例状态是 pending，则不做任何处理

  如果已经变为 fulfilled/rejected，则会通知对应对应的回调函数执行（不是立即执行，而是把其放置在 EventQueue 中的微任务队列中）

```js
let p = new Promise((resolve, reject) => {
  console.log(1)
  setTimeout(() => {
    resolve('OK')
    // 改变实例的状态和值【同步】
    // 通知之前基于then存放的onfulfilledCallback执行【异步微任务：也就是把执行方法的事情放置在EventQueue中的微任务队列中】
    console.log(4)
  }, 1000)
  console.log(2)
})
// 此时接收onfulfilledCallback的时候，状态还是pending，此时只是把方法存储起来
p.then(result => {
  console.log('成功', result)
})
console.log(3)
// 等1000ms后，执行定时器中的函数【把异步宏任务拿出来执行】
```

可以不给 then 传递第二个参数，只在最后写一个 catch 

- 如果 onfulfilledCallback 和 onrejectedCallback 不传递，则状态和结果都会 "顺延/传递" 到下一个同等状态应该执行的回调函数上（内部其实是自己补充一些实现效果的默认函数）

```js
new Promise((resolve, reject) => {
  reject('NO')
})
  .then(result => {
    console.log('成功', result)
  })
  .then(result => {
    console.log('成功', result)
  })
  .catch(reason => {
    console.log('失败', reason)
  })
```

catch 原理如下：

```js
// catch只处理状态为失败下做的事情
Promise.prototype.catch = function (onrejectedCallback) {
  return this.then(null, onrejectedCallback)
}
```

### Promise.all

`Promise.all([promise数组：要求数组中的每一项尽可能都是promise实例])`：返回一个新的 Promise 实例 AA，AA 成功还是失败，取决于数组中每一个 Promise 实例是成还是失败，只要有一个是失败，AA 就是失败，只有都成功 AA 才是成功的

`Promise.race([promise数组])`：最先知道状态的 promise 实例，是成功还是失败，决定了 AA 是成功还是失败

```js
function fn(interval) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(interval)
    }, interval)
  })
}

let p1 = fn(3000)
let p2 = fn(1000)
let p3 = Promise.resolve(0)

Promise.all([p1, p2, p3])
  .then(result => {
    // 不论谁先知道状态，最后结果的顺序和传递数组的顺序保持一致
    console.log(result)
  })
  .catch(reason => {
    // 处理过程中，遇到一个失败，则all立即为失败，结果就是当前失败的原因
    console.log(reason)
  })
```

jQuery：$.ajax 基于回调函数的方式管理异步编程

- 并行处理

```js
let total = 3,
  i = 0

function complete() {
  i++
  if (i == total) {
    //...
  }
}

$.ajax({
  url: 'api1',
  success(result1) {},
})
$.ajax({
  url: 'api2',
  success(result2) {},
})
$.ajax({
  url: 'api3',
  success(result3) {},
})
```

- 串行处理（回调地狱）

```js
// 回调地狱
$.ajax({
  url: 'api1',
  success(result1) {
    $.ajax({
      url: 'api2',
      success(result2) {
        $.ajax({
          url: 'api3',
          success(result3) {},
        })
      },
    })
  },
})
```

- 结合 Promise 处理 ajax 并行串行

```js
const api1 = () => {
  return new Promise(resolve => {
    $.ajax({
      url: 'api1',
      success(result1) {
        resolve()
      },
    })
  })
}
const api2 = () => {
  return new Promise(resolve => {
    $.ajax({
      url: 'api2',
      success(result2) {
        resolve()
      },
    })
  })
}
const api3 = () => {
  return new Promise(resolve => {
    $.ajax({
      url: 'api3',
      success(result3) {
        resolve()
      },
    })
  })
}

// 串行写法
api1()
  .then(result1 => {
    return api2()
  })
  .then(result2 => {
    return api3()
  })
  .then(result3 => {})

// 并行写法
Promise.all([api1(), api2(), api3()]).then(results => {})
```

- 使用 ES7 async+await

```js
(async function () {
  let result1 = await api1()
  let result2 = await api2()
  let result3 = await api3()
})()
```

## Promise执行顺序

```js
new Promise(resolve => {
  console.log('promise1')
  resolve()
})
  .then(() => {
    console.log('then11')
    new Promise(resolve => {
      console.log('promise2')
      resolve()
    })
      .then(() => {
        console.log('then21')
      })
      .then(() => {
        console.log('then22')
      })
  })
  .then(() => {
    console.log('then12')
  })
/* 
promise1
then11
promise2
then21
then12
then22
*/
```

![](https://gitee.com/lilyn/pic/raw/master/js-img/20210831175732.png)

1. 微任务1执行，碰到 `resolve()` ，通知微任务3可以执行，执行到底部，通知微任务2可以执行
2. 微任务3等到主线程一空闲执行，通知微任务4可以执行

微任务3比微任务2先达到可执行条件（不是谁先放先执行谁，是谁先达到可以执行条件执行谁）
