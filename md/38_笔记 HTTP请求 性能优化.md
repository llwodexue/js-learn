[toc]

# 38\_笔记

## HTTP请求

1. 解析url并发送URL请求
2. DNS域名解析
3. 和服务器建立TCP连接（三次握手）
4. 把客户端信息传递给服务器（发送HTTP请求）
5. 服务器收到并处理请求（HTTP响应内容）
6. 和服务器断开TCP连接（四次挥手）
7. 客户端渲染服务器返回的内容

### DNS解析

> 把模块下载到项目里和下载到全局的区别：
>
> - 在全局下载的话，每一个项目都可以用，在当前项目里下载只能在当前项目里使用



1. DNS解析

   当发送请求的时候，先把请求发送到DNS服务器（DNS上存储着每一个域名相对应的服务器IP地址），找到当前域名对应的IP地址，然后再向这个IP地址发送请求找到对应的服务器

2. DNS优化

   DNS缓存（一般浏览器会在第一次解析后，默认建立缓存，时间很短，大概几分钟）

   做DNS预获取dns-prefetch（在页面开始加载的时候，就把当前页面中需要访问的其它域名信息提前进行DNS解析，以后加载到具体内容时就可以不用域名解析了）

   ```html
   <!-- link是异步的 DNS预解析 -->
   <link rel="dns-prefetch" href="//static.360buyimg.com"/>
   <link rel="dns-prefetch" href="//misc.360buyimg.com"/>
   <link rel="dns-prefetch" href="//img10.360buyimg.com"/>
   <link rel="dns-prefetch" href="//img11.360buyimg.com"/>
   ```

   减少DNS解析次数（一个网站中发送的请求域名和服务器尽可能减少）

   

### 建立TCP连接

根据TCP的包头字段，存在3个重要的标识ACK、SYN、FIN

- ACK：表示验证字段
- SYN：位数置1，表示建立TCP连接
- FIN：位数置1，表示断开TCP连接



**三次握手**

1. 浏览器需发送一个SYN码给服务器。告诉服务器我要和你建立连接
2. 服务器接收SYN码之后，服务器给客户端发送一个SYN+ACK码。告诉客户端咱们客户建立连接
3. 客户端收到ACK码之后验证是否正确，如果正确，再向服务器发送一个ACK码。告诉服务端好的，咱们马上建立连接吧

![三次握手](https://gitee.com/lilyn/pic/raw/master/js-img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

TCP三次握手，A发出前需要确认，B不在就不给发。面向连接是指两个之间都有沟通，B如果发现A发的包是错的，会让A重新发一遍

TCP三次握手通俗理解，C→S：在不在，S→C：我在你在不在，C→S：我在

### 发送HTTP请求

请求报文：所有经过传输协议，客户端发送给服务端的内容，都是请求报文

- 请求体
- 请求头

响应报文：所有经过传输协议，服务端响应给客户端内容，都是响应报文

- HTTP状态码
- 响应头
- 响应体

HTTP报文：请求报文+响应报文



### 断开TCP连接

**四次挥手**

1. 当客户端无数据要传输了，会发送FIN码告诉服务器。我发送完毕了
2. 当服务端接受完毕后，告诉客户端ACK码。告诉客户端你可以把数据通道关闭了
3. 当服务端发送完毕之后，也会发送FIN码。告诉浏览器，数据发送完毕
4. 当客户端接收完毕之后同样发送ACK码。告诉服务器，数据接收完毕，你可以关闭

三次握手和四次挥手的好处：确保数据的安全和完整

![四次挥手](https://gitee.com/lilyn/pic/raw/master/js-img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

TCP四次挥手通俗理解，C→S：我要走了，S→C：等下，我看看还有没有数据要传输，C→S：好了，没事了，挂了吧（已经挂了），C→S：挂了

## HTTP状态码

**1xx：通知**

**2xx：成功**

- 200 OK：成功

![200](https://gitee.com/lilyn/pic/raw/master/js-img/200%20OK.jpg)

- 201 CREATE：一般应用于告诉服务器创建一个新文件，最后服务器创建成功以后返回状态码
- 204 NO CONTENT：对于某些请求(例如PUT或者DELETE)，服务器不想处理，可以返回空内容，但是这次请求也是成功的，返回状态码是204

**3xx：重定向**

- 301：永久重定向一般用于域名的迁移

![301](https://gitee.com/lilyn/pic/raw/master/js-img/301%20moved%20permanently.jpg)

- 302：临时转移之前302做临时转移的事，现在是307代表这个意思了==>服务器的负载均衡等
- 304：设置HTTP的协商缓存，走缓存（当前资源已经请求过，不再发送请求，直接使用缓存中的资源）

![304](https://gitee.com/lilyn/pic/raw/master/js-img/304%20not%20modified.jpg)

**4XX：客户端错误**

- 400：请求无效（传递给服务器的参数错误）
- 401：没有权限访问
- 403：禁止访问
- 404：无法找到文件（请求地址错误）

**5XX：服务端错误**

- 500：服务器的未知错误
- 503：服务器超负荷

## 启动服务器

- 一般来说，web服务器和数据服务器是同一台服务器的情况下(而且协议、域名、端口号都一致)，这种情况下载请求时是**同源策略**==>**同域**

- 但是真实的项目中往往两台服务器是分开的，此时的请求就是**非同源策略** =>**跨域** 

  "跨域资源共享"（Cross-origin resource sharing）

### 浏览器的渲染

在渲染的时候遇到 link/img/video/audio 等都是异步去加载信息(浏览器会分配一个新的线程只执行当前的任务，主线程继续往下走)，但是遇到script、@import，必须是同步加载信息了，当信息加载完成之后，主线程才会继续往下走

### DOM的回流和重绘

- 重绘：元素的样式改变，但是元素的大小，位置，宽高不变
- 回流：元素的大小或者位置发生的变化，会触发重新布局，导致render Tree进行重新的布局和渲染

注意：回流一定会引发重绘，但是重绘不会引发回流

### 前端性能优化

1. 放弃传统的操作 DOM 的时代，基于react、vue去写你的项目，(特点是数据影响视图的模式，框架内部操作的是虚拟的DOM，还会进行DOM-diff的对比)

   - jQuery 操作DOM，引起DOM回流重绘，vue、react操作虚拟DOM，不会引起DOM回流重绘

2. DOM操作的**读写分离**
   现代版的浏览器有一个"渲染队列"的机制，如果发现某一行要修改元素的样式，不会立即进行渲染，他要看看下一行是否还要进行元素样式的修改，如果是，那就把上一次的修改样式放到渲染队列里，这个过程一致持续到不是修改样式的操作为止，整体进行一次渲染引发一次回流

   - js 中的13个盒子模型和 getComputedStyle 都会引发渲染队列的刷新

3. 样式的集中改变

   `box.style.cssText = "width:100px;height:100px"`

4. 缓存布局信息

   `box.style.width = box.offsetWidth + 1 + "px"`

5. 文档碎片 createDocumentFragment 或 模板字符串

   文档碎片其实就是一个DOM容器 `#document-fragment`

6. css3 硬件加速

   transform opacity filter 不发生回流

   ```
   html,body {
   	filter: grayscale(100%);
   }
   ```

7. 牺牲平滑度换取速度

## 参考

[TCP三次握手和四次挥手以及11种状态](https://blog.51cto.com/jinlong/2065461)

[Http消息头中常用的请求头和响应头](https://www.cnblogs.com/widget90/p/7650890.html)

[常见的HTTP状态码](https://www.cnblogs.com/xflonga/p/9368993.html)

